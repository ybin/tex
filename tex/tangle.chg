TANGLE.CHG - WEB change file for TANGLE 4.4 for MS-DOS and Turbo Pascal.
Requires Turbo Pascal Version 5.0 or later

Compiler conditionals:
  temp     -- required, for DosTP unit
  Debug    -- optional, generate code for debugging (and range checking)
  Stat     -- optional, generate statistics

DOS-TP 0.4: Written by Peter Breitenlohner, November 1988.
            Most of the inline code is based on or inspired by an
            earlier version by Wayne Sullivan.

DOS-TP 0.5: Improved handling of Turbo Pascal type hex constants.
                                             P. Breitenlohner  25 Apr 89

DOS-TP 0.6: Better handling of array like macros (recursive calls),
   new names for TANGLE-TP directives.       P. Breitenlohner  21 Sep 89

DOS-TP 0.7: modified file name handling.     P. Breitenlohner  05 Oct 90

DOS-TP 1.0: first `official' version         P. Breitenlohner  31 Mar 92

DOS-TP 1.1: Adapted for TP6 (and 7) - built-in assembler and objects
                                             P. Breitenlohner  17 Aug 93

Dos-TP 2.0 and later use the Dos-TP unit.    P. Breitenlohner  16 Oct 95

% All line numbers refer to TANGLE.WEB 4.4, as of February 28, 1993.

% Modify the change in module 3 in order to create a split file or unit.
% Range checking will be turn on only when debugging with a unit.

@x limbo l.22
% Here is TeX material that gets inserted after \input webmac
@y
% This version of TANGLE for Turbo Pascal contains the following
%    extensions of standard TANGLE:
% - directives for conditional compilation
% - directives to create include files and/or units
% - 'and', 'shl', and 'shr' are treated in the same way as 'div' and 'mod',
%   'or' and 'xor' are treated according to Turbo Pascal operator precedence
% - array type macros

% Here is TeX material that gets inserted after \input webmac
@z
%---------------------------------------
@x limbo l.26
\def\PASCAL{Pascal}
@y
\def\PASCAL{Pascal}
\def\TP{\hbox{Turbo Pascal}} % Version 5.0 or later
\font\logo=logo10 % font used for the METAFONT logo
\def\MF{{\logo META}\-{\logo FONT}}
@z
%---------------------------------------
@x limbo l.33 - print changed modules only
\def\contentspagenumber{123} % should be odd
@y
\let\maybe=\iffalse
\def\contentspagenumber{123} % should be odd
@z
%---------------------------------------
@x limbo l.40
  \vfill}
@y
  \centerline{(Changes for Dos-TP Version 2.0, October 1995)}
  \vfill}
@z
%---------------------------------------
@x [1] m.1 l.63 - general comment
@!@^system dependencies@>
@y
@!@^system dependencies@>

This is \.{TANGLE-TP}, a version of \.{TANGLE} with some additional
capabilities when implementing very large \PASCAL\ program with \TP.
@.TANGLE-TP@>
When implementing a very large \PASCAL\ program for \TP\ running under
\.{DOS}, there are basically four problems caused by the architecture of
the \.{INTEL} 8086 microprocessor: (1)~One or several \TP\ units have to
be split off the program such that the code segment of each part doesn't
exceed the 64~kB limit for code segments; (2)~several large arrays must
be acquired dynamically from the heap, such that all remaining global
variables fit into the 64~kB limit for the data segment; (3)~one or
several huge arrays may exceed the 64~kB limit for each single
structured variable; and (4)~the program, together with its data, may
not fit into the 640~kB of memory directly addressable by \.{DOS}.

This is \.{TANGLE-TP}, a version of \.{TANGLE} specifically designed for
@.TANGLE-TP@>
\TP\ and \.{DOS} with some additional capabilities; all technical
details are explained in examples (files `\.{demo*.web}') which should
accompany this program.

To solve problem~(1) we use one of these capabilities: The \.{TANGLE-TP}
directive |TP_unit name| indicates the start of a \TP\ unit `|name|' and
|TP_main| indicates the start of the main module; \.{TANGLE-TP} takes
care of creating the interface and implementation parts for the units,
as well as of procedure or function declarations forwarded across units.
Similarly the |TP_split name| directive indicates the start of a section
of code to be written to a separate (`split') file |name|, such that all
\PASCAL\ files generated by \.{TANGLE-TP} respect the 64~kB limit
imposed by the \.{IDE} version of the \TP\ compiler.

Problem (2) is easily solved with the help of \.{WEB} macros: if the
original program contains the array declaration
$$\vbox{\halign{\hskip.25\hsize\ignorespaces#\hfil\cr
|var this: array [any] of some;|\cr
\noalign{\leftline{\strut}}
\noalign{\leftline{\strut then we simply replace this by}}
\noalign{\leftline{\strut}}
\&{define} |this==p_this^|\cr
\noalign{\leftline{\strut}}
|type a_this=array [any] of some;|\cr
|var p_this: ^a_this;|\cr}}$$
and initialize the pointer variable |p_this| via |new(p_this)|.

As a pleasant surprise, \TP\ offers an elegant solution to problem~(3)
through a documented extension of the \PASCAL\ standard: given once
again an array declaration for |this| as above, one can replace each
reference to an array element |this[i]| (either in an expression or on
the left hand side of an assignment) by the dereferenced result
|f_this(i)^| of a suitable pointer valued function. Once again
\.{TANGLE-TP} helps in doing these replacements implicitely through
an `array-type' \.{WEB} macro:
$$\vbox{\halign{\hskip.25\hsize\ignorespaces#\hfil\cr
\&{define} |this[#]==f_this(#)^|\cr
\noalign{\leftline{\strut}}
|type p_some=^some;|\cr
|function f_this(i:any):p_some;| \C{returns pointer to |this[i]|}\cr}}$$
For reasons of efficiency the function |f_this| should be written in
assembler or as inline code.

Finally, problem~(4) can be solved very much like problem~(3) with the
help of \.{WEB} and \.{TANGLE-TP}. `All' there remains to do, is to
define a suitable function |f_this| for the necessary address
translation and virtual memory management. For reasons of efficiency
at least part of this should be done in assembler.

Unfortunatly, there is an unpleasant surprise with \TP as well: If |j|
and |k| are declared as unsigned integers (i.e., as |Byte| or |Word|)
then the difference |j-k| is computed as unsigned number (i.e., is taken
modulo $2^{16}$) even in an assignment |i:=j-k| where |i| is declared as
signed integer (|Short_Int|, |Integer|, or |integer==Long_Int|).
@z
%---------------------------------------
@x [1] m.1 l.68 - banner
@d banner=='This is TANGLE, Version 4.4'
@y
@d banner=='This is TANGLE-TP, Version 4.4'
@z
%---------------------------------------
@x [1] m.2 l.82 - unit Dos_TP and Dos
program TANGLE(@!web_file,@!change_file,@!Pascal_file,@!pool);
@y
program TANGLE(@!web_file,@!change_file,@!Pascal_file,@!pool);
uses Dos, DosTP; {for file and path names}
@z
%---------------------------------------
@x [1] m.2 l.86 - typed constants, large arrays, unit
var @<Globals in the outer block@>@/
@y
split_or_unit()(TP_unit tglsplit@; compiler_directives_for_unit)
  {start of TP unit |tglsplit|}
const @<Typed constants in the outer block@>@/
var @<Globals in the outer block@>@/
@<Small arrays in the outer block@>@/
@<Large arrays in the outer block@>@/
@z
%---------------------------------------
@x [1] m.2 l.88 - split file
procedure initialize;
@y
split_or_unit(TP_split tglsplit)()
  {start sending code to file |tglsplit.pas|}
procedure initialize;
@z
%---------------------------------------
@x [1] m.3 l.98 - debug ... gubed, split file or unit
@d debug==@{ {change this to `$\\{debug}\equiv\null$' when debugging}
@d gubed==@t@>@} {change this to `$\\{gubed}\equiv\null$' when debugging}
@y
@d split_or_unit==do_none {change this to |split_or_unit==do_split| for
  a split file or to |split_or_unit==do_unit| for a unit}
@#
@d debug==TP_ifdef Debug
@d gubed==TP_endif
@z
%---------------------------------------
@x [1] m.3 l.103 - stat ... tats
@d stat==@{ {change this to `$\\{stat}\equiv\null$'
  when gathering usage statistics}
@d tats==@t@>@} {change this to `$\\{tats}\equiv\null$'
  when gathering usage statistics}
@y
@d stat==TP_ifdef Stat
@d tats==TP_endif
@z
%---------------------------------------
@x [1] m.4 l.118 - compiler directives
@<Compiler directives@>=
@{@&$C-,A+,D-@} {no range check, catch arithmetic overflow, no debug overhead}
@!debug @{@&$C+,D+@}@+ gubed {but turn everything on when debugging}
@y
@d TP_dir(#)==@\@={$@>#@=}@>

@<Compiler directives@>=
TP_dir(R-,S+,I+,D+,F-) {no range check}
split_or_unit()(@!debug TP_dir(R+)@+ gubed) {but turn range check on
  when debugging (and creating a unit)}
@z
%---------------------------------------
@x [1] m.6 l.143 - programming idioms
@d incr(#) == #:=#+1 {increase a variable by unity}
@d decr(#) == #:=#-1 {decrease a variable by unity}
@y
We will use a \.{WEB} coding trick and use names such as |Length|,
|String| and |Close| for the \TP\ predefined identifiers, in order
to avoid name conflicts with the \.{WEB} macros |length| (used in
\TeX\ and \MF), or |string| and |close| (used in \.{WEAVE}).

@d integer==Long_Int {we will use |Integer| for two-byte integers}
@#
@d incr(#) == Inc(#) {increase a variable by unity}
@d decr(#) == Dec(#) {decrease a variable by unity}
@z
%---------------------------------------
@x [1] m.7 l.172 - othercases
@d othercases == others: {default for cases not listed explicitly}
@y
@d othercases == else {default for cases not listed explicitly}
@z
%---------------------------------------
@x [1] m.8 l.177 - enlarge constants
@ The following parameters are set big enough to handle \TeX, so they
@y
@ The following parameters are set big enough to handle PubliC \TeX, so they
@z
%---------------------------------------
@x [1] m.8 l.182 constants - enlarge max_bytes
@!max_bytes=45000; {|1/ww| times the number of bytes in identifiers,
@y
@!max_bytes=50000; {|1/ww| times the number of bytes in identifiers,
@z
%---------------------------------------
@x [1] m.8 l.184 constants - enlarge max_toks (for zz=4)
@!max_toks=50000; {|1/zz| times the number of bytes in compressed \PASCAL\ code;
@y
@!max_toks=45000; {|1/zz| times the number of bytes in compressed \PASCAL\ code;
@z
%---------------------------------------
@x [1] m.8 l.186 constants - enlarge max_names
@!max_names=4000; {number of identifiers, strings, module names;
@y
@!max_names=5000; {number of identifiers, strings, module names;
@z
%---------------------------------------
@x [1] m.8 l.188 constants - enlarge max_texts
@!max_texts=2000; {number of replacement texts, must be less than 10240}
@y
@!max_texts=2500; {number of replacement texts, must be less than 10240}
@z
%---------------------------------------
@x [1] m.8 l.194 constants - enlarge max_id_length
@!max_id_length=12; {long identifiers are chopped to this length, which must
  not exceed |line_length|}
@y
@!max_id_length=14; {long identifiers are chopped to this length, which must
  not exceed |line_length|; \&{implementation} is that long}
@z
%---------------------------------------
@x [2] m.12 l.305 - file handling, typed constants
@!text_file=packed file of text_char;
@y
@!text_file=text;@;@/
@!Xchr= array [ASCII_code] of text_char;
  {specifies conversion of output characters}
@!ASCII_array=array [0..7] of array [1..32] of char;
@z
%---------------------------------------
@x [2] m.13 l.311 - file handling, large arrays
@<Globals...@>=
@y
@d xchr_length==Byte(xchr_string[0]) {actual length of |xchr_string|}

@<Small arrays...@>=
@!xchr_string:String; {for input and output of |text_char|'s}
@z
%---------------------------------------
@x [2] m.13 l.314 - typed constants
@!xchr: array [ASCII_code] of text_char;
  {specifies conversion of output characters}
@y
@z
%---------------------------------------
@x [2] m.14 l.332 - typed constants
@<Set init...@>=
xchr[@'40]:=' ';
xchr[@'41]:='!';
xchr[@'42]:='"';
xchr[@'43]:='#';
xchr[@'44]:='$';
xchr[@'45]:='%';
xchr[@'46]:='&';
xchr[@'47]:='''';@/
xchr[@'50]:='(';
xchr[@'51]:=')';
xchr[@'52]:='*';
xchr[@'53]:='+';
xchr[@'54]:=',';
xchr[@'55]:='-';
xchr[@'56]:='.';
xchr[@'57]:='/';@/
xchr[@'60]:='0';
xchr[@'61]:='1';
xchr[@'62]:='2';
xchr[@'63]:='3';
xchr[@'64]:='4';
xchr[@'65]:='5';
xchr[@'66]:='6';
xchr[@'67]:='7';@/
xchr[@'70]:='8';
xchr[@'71]:='9';
xchr[@'72]:=':';
xchr[@'73]:=';';
xchr[@'74]:='<';
xchr[@'75]:='=';
xchr[@'76]:='>';
xchr[@'77]:='?';@/
xchr[@'100]:='@@';
xchr[@'101]:='A';
xchr[@'102]:='B';
xchr[@'103]:='C';
xchr[@'104]:='D';
xchr[@'105]:='E';
xchr[@'106]:='F';
xchr[@'107]:='G';@/
xchr[@'110]:='H';
xchr[@'111]:='I';
xchr[@'112]:='J';
xchr[@'113]:='K';
xchr[@'114]:='L';
xchr[@'115]:='M';
xchr[@'116]:='N';
xchr[@'117]:='O';@/
xchr[@'120]:='P';
xchr[@'121]:='Q';
xchr[@'122]:='R';
xchr[@'123]:='S';
xchr[@'124]:='T';
xchr[@'125]:='U';
xchr[@'126]:='V';
xchr[@'127]:='W';@/
xchr[@'130]:='X';
xchr[@'131]:='Y';
xchr[@'132]:='Z';
xchr[@'133]:='[';
xchr[@'134]:='\';
xchr[@'135]:=']';
xchr[@'136]:='^';
xchr[@'137]:='_';@/
xchr[@'140]:='`';
xchr[@'141]:='a';
xchr[@'142]:='b';
xchr[@'143]:='c';
xchr[@'144]:='d';
xchr[@'145]:='e';
xchr[@'146]:='f';
xchr[@'147]:='g';@/
xchr[@'150]:='h';
xchr[@'151]:='i';
xchr[@'152]:='j';
xchr[@'153]:='k';
xchr[@'154]:='l';
xchr[@'155]:='m';
xchr[@'156]:='n';
xchr[@'157]:='o';@/
xchr[@'160]:='p';
xchr[@'161]:='q';
xchr[@'162]:='r';
xchr[@'163]:='s';
xchr[@'164]:='t';
xchr[@'165]:='u';
xchr[@'166]:='v';
xchr[@'167]:='w';@/
xchr[@'170]:='x';
xchr[@'171]:='y';
xchr[@'172]:='z';
xchr[@'173]:='{';
xchr[@'174]:='|';
xchr[@'175]:='}';
xchr[@'176]:='~';@/
xchr[0]:=' '; xchr[@'177]:=' '; {these ASCII codes are not used}
@y
@d xchr==Xchr(ASCII)

@<Typed constants...@>=
@!ASCII:ASCII_array=
  ('         '#9'  '#12#13'                  ',@/
   ' !"#$%&''()*+,-./0123456789:;<=>?',@/
   '@@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_',@/
   '`abcdefghijklmnopqrstuvwxyz{|}~ ',@/
   '                                ',@/
   '                                ',@/
   '                                ',@/
   '                                ');
@z
%---------------------------------------
@x [2] m.17 l.481 - typed constants
for i:=1 to @'37 do xchr[i]:=' ';
for i:=@'200 to @'377 do xchr[i]:=' ';
@y
@z
%---------------------------------------
@x [3] m.20 l.507 - terminal io
@d print(#)==write(term_out,#) {`|print|' means write on the terminal}
@y
@d term_out==Output {the terminal as an output file}
@#
@d print(#)==write(term_out,#) {`|print|' means write on the terminal}
@z
%---------------------------------------
@x [3] m.20 l.515 - terminal io, file names
@!term_out:text_file; {the terminal as an output file}
@y
@!chg_dir:Dir_Str; {dir part of change file name}
@!chg_name:Name_Str; {name part of change file name}
@!chg_ext:Ext_Str; {ext part of change file name}
@z
%---------------------------------------
@x [3] m.21 l.523 - terminal io, file names
rewrite(term_out,'TTY:'); {send |term_out| output to the terminal}
@y
File_Mode:=0;
if not i_name('.web') then
    begin F_Split(Param_Str(0),in_dir,in_name,in_ext);
    print_ln('Usage:  ',in_name,' [<web> [<chg> [<out>]]]'); Halt;
    end;
if Param_Count>n_opt then name_of_file:=Param_Str(n_opt+2)
else  begin print('Change file [',in_dir,in_name,'.chg]: ');
  read_ln(name_of_file);
  end;
F_Split(name_of_file,chg_dir,chg_name,chg_ext);
if chg_dir='' then chg_dir:=in_dir;
if chg_name='' then chg_name:=in_name;
if chg_ext='' then chg_ext:='.chg';
o_path(3);
@z
%---------------------------------------
@x [3] m.22 l.530 - terminal io
@d update_terminal == break(term_out) {empty the terminal output buffer}
@y
@d update_terminal ==
@z
%---------------------------------------
@x [3] m.24 l.546 - file handling
begin reset(web_file); reset(change_file);
@y
begin name_of_file:=in_dir+in_name+in_ext;
t_assign(web_file,name_of_file);
if not t_reset(web_file) then in_error;
name_of_file:=chg_dir+chg_name+chg_ext;
t_assign(change_file,name_of_file);
if not t_reset(change_file) then
  begin print_ln('No change file.'); change_limit:=0
  end
else change_limit:=1;
@z
%---------------------------------------
@x [3] m.26 l.560 - file handling
@^system dependencies@>

@<Set init...@>=
rewrite(Pascal_file); rewrite(pool);
@y
Files will be closed with the |Close| procedure.
We have to use a WEB coding trick in order to avoid an identifier
conflict with \.{WEAVE}'s numeric macro |close|.
@^system dependencies@>

@d a_close(#) == {close a text file}
  begin TP_dir(I-)@; Close(#); TP_dir(I+)@;
  if IO_Result<>0 then do_nothing;
  end

@<Open output files@>=
name_of_file:=out_dir+chg_name+'.pas';
t_assign(Pascal_file,name_of_file);
if not t_rewrite(Pascal_file) then out_error;
t_assign(pool,out_dir+in_name+'.poo');
TP_dir(I-)@; Erase(pool); TP_dir(I+)@;
if IO_Result<>0 then do_nothing; {don't yet open |pool|}
@z
%---------------------------------------
@x [3] m.28 l.586 input_ln - file handling
begin limit:=0; final_limit:=0;
if eof(f) then input_ln:=false
else  begin while not eoln(f) do
    begin buffer[limit]:=xord[f^]; get(f);
@y
@!i:Integer;
begin limit:=0; final_limit:=0;
if TP_dir(I-) eof(f) TP_dir(I+) or(IO_Result<>0) then input_ln:=false
else  begin read_ln(f,xchr_string); i:=0;
  while i<xchr_length do
    begin incr(i); buffer[limit]:=xord[xchr_string[i]];
@z
%---------------------------------------
@x [3] m.28 l.593 input_ln - file handling
      begin while not eoln(f) do get(f);
@y
      begin i:=xchr_length;
@z
%---------------------------------------
@x [3] m.28 l.600 input_ln - file handling
  read_ln(f); limit:=final_limit; input_ln:=true;
@y
  limit:=final_limit; input_ln:=true;
@z
%---------------------------------------
@x [4] m.31 l.632 - scan phase
The actual error indications are provided by a procedure called |error|.

@d err_print(#)==begin new_line; print(#); error;
@y
The actual error indications are provided by a procedure called |error|.
Error messages are, however, not reported during the scan phase, since
errors detected in the scan phase will be detected again during the
output phase.

@d err_print(#)==
  begin if not scan_phase then
    begin new_line; print(#); error;
    end;
@z
%---------------------------------------
@x [4] m.31 l.642 - scan phase
else @<Print error location based on output buffer@>;
@y
else if not scan_phase then
  @<Print error location based on output buffer@>;
@z
%---------------------------------------
@x [4] m.34 l.693 - close_files_and_terminate
procedure jump_out;
begin goto end_of_TANGLE;
@y
procedure close_files_and_terminate; forward;
@#
procedure jump_out;
begin close_files_and_terminate; Halt(history);
@z
%---------------------------------------
@x [5] m.37 l.726 - dynamic memory allocation
@!sixteen_bits=0..65535; {unsigned two-byte quantity}
@y
@!sixteen_bits=0..65535; {unsigned two-byte quantity}
@#
@!a_byte_mem=packed array [0..max_bytes] of ASCII_code;
  {characters of names}
@!a_tok_mem=packed array [0..max_toks] of eight_bits; {tokens}
@!a_tok_start=array [0..max_texts] of sixteen_bits;
  {directory into |tok_mem|}
@z
%---------------------------------------
@x [5] m.38 l.740 - dynamic memory allocation, optimization
@d ww=2 {we multiply the byte capacity by approximately this amount}
@d zz=3 {we multiply the token capacity by approximately this amount}
@y
@d ww=2 {we multiply the byte capacity by approximately this amount,
         must be a power of two}
@d zz=4 {we multiply the token capacity by approximately this amount,
         must be a power of two}
@#
@d ww1=ww-1
@d zz1=zz-1
@#
@d byte_mem[#]==p_byte_mem[#]^ {array-type macro, special for TANGLE-TP}
@d tok_mem[#]==p_tok_mem[#]^ {array-type macro, special for TANGLE-TP}
@d tok_start==p_tok_start^
@z
%---------------------------------------
@x [5] m.38 l.743 - large arrays
@<Globals...@>=
@y
@<Large arrays...@>=
@z
%---------------------------------------
@x [5] m.38 l.744 - dynamic memory allocation
@!byte_mem: packed array [0..ww-1,0..max_bytes] of ASCII_code;
  {characters of names}
@!tok_mem: packed array [0..zz-1,0..max_toks] of eight_bits; {tokens}
@y
@!p_byte_mem: array [0..ww1] of ^a_byte_mem; {characters of names}
@!p_tok_mem: array [0..zz1] of ^a_tok_mem; {tokens}
@z
%---------------------------------------
@x [5] m.38 l.748 - dynamic memory allocation
@!tok_start: array [0..max_texts] of sixteen_bits; {directory into |tok_mem|}
@y
@!p_tok_start: ^a_tok_start; {directory into |tok_mem|}
@z
%---------------------------------------
@x [5] m.42 l.800 - optimization
for wi:=0 to ww-1 do
@y
if (ww and ww1)<>0 then
  begin print_nl('! ww must be a power of two.'); mark_fatal; jump_out;
  end;
for wi:=0 to ww1 do
@z
%---------------------------------------
@x [5] m.42 l.801 - dynamic memory allocation
  begin byte_start[wi]:=0; byte_ptr[wi]:=0;
@y
  begin new(p_byte_mem[wi]); byte_start[wi]:=0; byte_ptr[wi]:=0;
@z
%---------------------------------------
@x [5] m.46 l.843 - dynamic memory allocation, optimization
for zi:=0 to zz-1 do
  begin tok_start[zi]:=0; tok_ptr[zi]:=0;
@y
if (zz and zz1)<>0 then
  begin print_nl('! zz must be a power of two.'); mark_fatal; jump_out;
  end;
new(p_tok_start);
for zi:=0 to zz1 do
  begin new(p_tok_mem[zi]); tok_start[zi]:=0; tok_ptr[zi]:=0;
@z
%---------------------------------------
@x [5] m.46 l.847 - optimization
text_ptr:=1; z:=1 mod zz;
@y
text_ptr:=1; z:=1 and zz1;
@z
%---------------------------------------
@x [5] m.47 l.867 - TP extensions
like simple identifiers, their |equiv| value points to the replacement text.
@y
like simple identifiers, their |equiv| value points to the replacement text.

\yskip\hang |array_type| identifiers have been defined to be array-type macros;
they are like parametric identifiers but the macro parameters and
arguments are enclosed in square brackets.
@z
%---------------------------------------
@x [5] m.47 l.872 - array_type macros
@d parametric=3 {parametric macros have |parametric| ilk}
@y
@d parametric=3 {parametric macros have |parametric| ilk}
@d array_type=4 {array-type macros have |array_type| ilk}
@z
%---------------------------------------
@x [5] m.49 l.897 - optimization
else  begin w:=p mod ww;
@y
else  begin w:=p and ww1;
@z
%---------------------------------------
@x [6] m.50 l.938 - optimization (for inline code)
@!id_first:0..buf_size; {where the current identifier begins in the buffer}
@y
@!id_first:Word; {where the current identifier begins in the buffer}
@z
%---------------------------------------
@x [6] m.53 l.963 id_lookup - optimization (for inline code)
@!i:0..buf_size; {index into |buffer|}
@y
@!i:Word; {index into |buffer|}
@z
%---------------------------------------
@x [6] m.53 l.967 id_lookup - optimization (for inline code)
@!l:0..buf_size; {length of the given identifier}
@y
@!l:Word; {length of the given identifier}
@z
%---------------------------------------
@x [6] m.54 l.983 - optimization
h:=buffer[id_first]; i:=id_first+1;
while i<id_loc do
  begin h:=(h+h+buffer[i]) mod hash_size; incr(i);
  end
@y
Inline($FC                {|cld|}
      /$BB/hash_size      {|mov bx,hash_size|}
      /$33/$C0            {|xor ax,ax|}
      /$33/$D2            {|xor dx,dx|}
      /$BE/buffer         {|mov si,buffer|}
      /$03/$36/id_first   {|add si,[id_first]|}
      /$8B/$4E/<l         {|mov cx,[bp+l]|}
      /$01/$D2       {|@@1: add dx,dx|}
      /$AC                {|lodsb|}
      /$03/$D0            {|add dx,ax|}
      /$2B/$D3       {|@@2: sub dx,bx|}
      /$7D/<-4            {|jge @@2|}
      /$03/$D3            {|add dx,bx|}
      /$E2/<-13           {|loop @@1|}
      /$89/$56/<h);       {|mov [bp+h],dx|}
@z
%---------------------------------------
@x [6] m.56 l.1003 - optimization
begin i:=id_first; k:=byte_start[p]; w:=p mod ww;
while (i<id_loc)and(buffer[i]=byte_mem[w,k]) do
  begin incr(i); incr(k);
  end;
@y
begin
Inline($FC                 {|cld|}
      /$8B/$76/<p          {|mov si,[bp+p]|}
      /$BB/>ww1            {|mov bx,ww1|}
      /$23/$DE             {|and bx,si|}
      /$01/$DB             {|add bx,bx|}
      /$01/$DB             {|add bx,bx|}
      /$01/$F6             {|add si,si|}
      /$C4/$BF/p_byte_mem  {|les di,[dx+p_byte_mem]|}
      /$03/$BC/byte_start  {|add di,[si+byte_start]|}
      /$BE/buffer          {|mov si,buffer|}
      /$03/$36/id_first    {|add si,[id_first]|}
      /$33/$C9             {|xor cx,cx|}
      /$8A/$4E/<l          {|mov cl,[bp+l]|}
      /$F3/$A6             {|repz cmpsb|}
      /$74/<+1             {|jz @@1|}
      /$4E                 {|dec si|}
      /$81/$EE/buffer {|@@1: sub si,buffer|}
      /$89/$76/<i);        {|mov [bp+i],si|}
@z
%---------------------------------------
@x [6] m.61 l.1075 - optimization
w:=name_ptr mod ww; k:=byte_ptr[w];
@y
w:=name_ptr and ww1; k:=byte_ptr[w];
@z
%---------------------------------------
@x [6] m.61 l.1079 - optimization
while i<id_loc do
  begin byte_mem[w,k]:=buffer[i]; incr(k); incr(i);
  end;
@y
move(buffer[i],byte_mem[w,k],id_loc-i); Inc(k,id_loc-i);
@z
%---------------------------------------
@x [6] m.63 l.1097 - optimization
begin k:=byte_start[q]; s:=0; w:=q mod ww;
@y
begin k:=byte_start[q]; s:=0; w:=q and ww1;
@z
%---------------------------------------
@x [6] m.64 l.1129 - file handling
  incr(string_ptr);
@y
  if string_ptr=256 then
    begin name_of_file:=out_dir+in_name+'.poo';
    if not t_rewrite(pool) then out_error;
    end;
  incr(string_ptr);
@z
%---------------------------------------
@x [7] m.67 l.1194 - optimization
w:=name_ptr mod ww; k:=byte_ptr[w];
@y
w:=name_ptr and ww1; k:=byte_ptr[w];
@z
%---------------------------------------
@x [7] m.68 l.1204 - optimization
begin k:=byte_start[p]; w:=p mod ww; c:=equal; j:=1;
@y
begin k:=byte_start[p]; w:=p and ww1; c:=equal; j:=1;
@z
%---------------------------------------
@x [8] m.73 l.1336 store_two_bytes - optimization
tok_mem[z,tok_ptr[z]]:=x div@'400; {this could be done by a shift command}
tok_mem[z,tok_ptr[z]+1]:=x mod@'400; {this could be done by a logical and}
@y
tok_mem[z,tok_ptr[z]]:=Hi(x); tok_mem[z,tok_ptr[z]+1]:=Lo(x);
@z
%---------------------------------------
@x [8] m.74 l.1351 print_repl - optimization
else  begin k:=tok_start[p]; zp:=p mod zz;
@y
else  begin k:=tok_start[p]; zp:=p and zz1;
@z
%---------------------------------------
@x [8] m.75 l.1365 - optimization
  begin a:=(a-@'200)*@'400+tok_mem[zp,k]; print_id(a);
  if byte_mem[a mod ww,byte_start[a]]="""" then print('"')
@y
  begin a:=Swap(a-@'200)+tok_mem[zp,k]; print_id(a);
  if byte_mem[a and ww1,byte_start[a]]="""" then print('"')
@z
%---------------------------------------
@x [8] m.75 l.1370 - optimization
  begin print('@@<'); print_id((a-@'250)*@'400+tok_mem[zp,k]);
@y
  begin print('@@<'); print_id(Swap(a-@'250)+tok_mem[zp,k]);
@z
%---------------------------------------
@x [8] m.75 l.1373 - optimization
else  begin a:=(a-@'320)*@'400+tok_mem[zp,k]; {module number}
@y
else  begin a:=Swap(a-@'320)+tok_mem[zp,k]; {module number}
@z
%---------------------------------------
@x [9] m.82 l.1464 - array_type macros
@!brace_level: eight_bits; {current depth of $\.{@@\{}\ldots\.{@@\}}$ nesting}
@y
@!brace_level: eight_bits; {current depth of $\.{@@\{}\ldots\.{@@\}}$ nesting}
@!array_comma: boolean; {|true| if comma has ended |array_type| parameter}
@z
%---------------------------------------
@x [9] m.83 l.1474 - optimization, array_type macros
zo:=cur_repl mod zz; cur_byte:=tok_start[cur_repl];
@y
array_comma:=false;
zo:=cur_repl and zz1; cur_byte:=tok_start[cur_repl];
@z
%---------------------------------------
@x [9] m.84 l.1485 push_level - optimization
  cur_name:=p; cur_repl:=equiv[p]; zo:=cur_repl mod zz;
@y
  cur_name:=p; cur_repl:=equiv[p]; zo:=cur_repl and zz1;
@z
%---------------------------------------
@x [9] m.85 l.1500 pop_level - array_type macros
  begin if ilk[cur_name]=parametric then
@y
  begin array_comma:=(ilk[cur_name]=array_type); {tentatively}
  if ilk[cur_name]>=parametric then
@z
%---------------------------------------
@x [9] m.85 l.1505 pop_level - optimization
  zo:=cur_repl mod zz;
@y
  zo:=cur_repl and zz1;
@z
%---------------------------------------
@x [9] m.85 l.1511 pop_level - optimization, array_type macros
  begin cur_state:=stack[stack_ptr]; zo:=cur_repl mod zz;
@y
  begin cur_state:=stack[stack_ptr]; zo:=cur_repl and zz1;
  if array_comma then
    if tok_mem[zo,cur_byte-1]="," then decr(cur_byte)
    else array_comma:=false;
@z
%---------------------------------------
@x [9] m.87 l.1542 get_output - array_type macros
@!w:0..ww-1; {segment of |byte_mem|}
@y
@!w:0..ww-1; {segment of |byte_mem|}
@!array_param:boolean; {are we scanning an |array_type| macro parameter?}
@z
%---------------------------------------
@x [9] m.87 l.1551 get_output - array_type macros
a:=tok_mem[zo,cur_byte]; incr(cur_byte);
@y
a:=tok_mem[zo,cur_byte]; incr(cur_byte);
if array_comma then  begin array_comma:=false; a:="[";
  end;
@z
%---------------------------------------
@x [9] m.87 l.1556 get_output - optimization
a:=(a-@'200)*@'400+tok_mem[zo,cur_byte]; incr(cur_byte);
@y
a:=Swap(a-@'200)+tok_mem[zo,cur_byte]; incr(cur_byte);
@z
%---------------------------------------
@x [9] m.87 l.1562 get_output - scan phase
found:
@y
found:
@<Analyze the syntax of Pascal code@>;
@z
%---------------------------------------
@x [9] m.88 l.1573 - scan phase
else if a<>0 then
@y
else if (a<>0)and not scan_phase then
@z
%---------------------------------------
@x [9] m.89 l.1582 - TP extensions
normal: begin cur_val:=a; a:=identifier;
@y
normal: begin
  @<If this identifier is new then change |link| and clear |equiv|@>;
  cur_val:=a; a:=identifier;
@z
%---------------------------------------
@x [9] m.89 l.1584 - arithmetic
numeric: begin cur_val:=equiv[a]-@'100000; a:=number;
@y
numeric: begin cur_val:=integer(equiv[a])-@'100000; a:=number;
@z
%---------------------------------------
@x [9] m.89 l.1588 - array_type macros
parametric: begin @<Put a parameter on the parameter stack,
@y
parametric,array_type: begin @<Put a parameter on the parameter stack,
@z
%---------------------------------------
@x [9] m.90 l.1599 - array_type macros
a level that hasn't ended. Then the next character must be a `\.(';
and since parentheses are balanced on each level, the entire parameter must
@y
a level that hasn't ended. Then the next character must be a `\.(' or
`|[|'; and since parentheses and (for |array_type| macros) brackets must
be balanced on each level, the entire parameter must
@z
%---------------------------------------
@x [9] m.90 l.1605 - array_type macros
if (stack_ptr=0)or(tok_mem[zo,cur_byte]<>"(") then
  begin print_nl('! No parameter given for '); print_id(a); error;
@.No parameter given for macro@>
@y
if (stack_ptr=0)or
   (ilk[a]=parametric)and(tok_mem[zo,cur_byte]<>"(")or
   (ilk[a]=array_type)and(tok_mem[zo,cur_byte]<>"[") then
 if array_comma and(ilk[a]=array_type) then array_comma:=false
 else begin if not scan_phase then
    begin print_nl('! No parameter given for '); print_id(a); error;
@.No parameter given for macro@>
    end;
@z
%---------------------------------------
@x [9] m.90 l.1611 - optimization
equiv[name_ptr]:=text_ptr; ilk[name_ptr]:=simple; w:=name_ptr mod ww;
@y
equiv[name_ptr]:=text_ptr; ilk[name_ptr]:=simple; w:=name_ptr and ww1;
@z
%---------------------------------------
@x [9] m.90 l.1621 - optimization
z:=text_ptr mod zz
@y
z:=text_ptr and zz1
@z
%---------------------------------------
@x [9] m.91 l.1628 - optimization
z:=text_ptr mod zz;
@y
z:=text_ptr and zz1;
@z
%---------------------------------------
@x [9] m.91 l.1632 - optimization
@!debug decr(byte_ptr[name_ptr mod ww]);@+gubed
@y
@!debug decr(byte_ptr[name_ptr and ww1]);@+gubed
@z
%---------------------------------------
@x [9] m.93 l.1646 - array_type macros
still must distinguish `real' parentheses from those in strings.
@y
still must distinguish `real' parentheses from those in strings.

The token which terminates the parameter of an |array_type| macro will
be reanalyzed by |pop_level|.
@z
%---------------------------------------
@x [9] m.93 l.1652 - array_type macros
bal:=1; incr(cur_byte); {skip the opening `\.('}
loop@+  begin b:=tok_mem[zo,cur_byte]; incr(cur_byte);
@y
bal:=1; incr(cur_byte); {skip the opening `\.(' or `|[|'}
array_param:=(ilk[a]=array_type);
loop@+  begin if cur_byte=cur_end then
    begin print_nl('! Incomplete parameter for '); print_id(a); error;
@.Incomplete parameter for macro@>
    tok_ptr[z]:=tok_start[text_ptr]; goto restart; {forget it}
    end;
  b:=tok_mem[zo,cur_byte]; incr(cur_byte);
@z
%---------------------------------------
@x [9] m.93 l.1654 - arithmetic
  if b=param then store_two_bytes(name_ptr+@'77777)
@y
  if b=param then store_two_bytes(Word(name_ptr)+@'77777)
@z
%---------------------------------------
@x [9] m.93 l.1661 - array_type macros
      ")":  begin decr(bal);
        if bal=0 then goto done;
        end;
@y
      "[": if array_param then incr(bal);
      ")":  begin decr(bal);
        if (bal=0)and not array_param then goto done;
        end;
      "]": if array_param then
        if bal=1 then goto done @+ else decr(bal);
      ",": if array_param and (bal=1) then goto done;
@z
%---------------------------------------
@x [10] m.94 l.1720 - TP extensions
@!semi_ptr: 0..out_buf_size; {last semicolon breaking place in |out_buf|}
@y
@!semi_ptr: 0..out_buf_size; {last semicolon breaking place in |out_buf|}
@!p_line: Integer; {next output line to be indicated on the terminal}
@!n_line: Integer; {next output line to be shown on the terminal}
@z
%---------------------------------------
@x [10] m.96 l.1796 - TP extensions
out_state:=misc; out_ptr:=0; break_ptr:=0; semi_ptr:=0; out_buf[0]:=0; line:=1;
@y
out_state:=misc; out_ptr:=0; break_ptr:=0; semi_ptr:=0; out_buf[0]:=0; line:=1;
p_line:=100; n_line:=500;
@z
%---------------------------------------
@x [10] m.97 l.1807 flush_buffer - optimization
var k:0..out_buf_size; {index into |out_buf|}
@!b:0..out_buf_size; {value of |break_ptr| upon entry}
@y
var @!b:0..out_buf_size; {value of |break_ptr| upon entry}
@z
%---------------------------------------
@x [10] m.97 l.1811 flush_buffer - TP extensions, optimization
for k:=1 to break_ptr do write(Pascal_file,xchr[out_buf[k-1]]);
write_ln(Pascal_file); incr(line);
if line mod 100 = 0 then
  begin print('.');
  if line mod 500 = 0 then print(line:1);
@y
xchr_length:=break_ptr;
if xchr_length>0 then
Inline($FC                {|cld|}
      /$BE/out_buf        {|mov si,out_buf|}
      /$BB/ASCII          {|mov bx,ASCII|}
      /$8C/$D8/$8E/$C0    {|mov ax,ds; mov es,ax|}
      /$BF/xchr_string+1  {|mov di,xchr_string+1|}
      /$31/$C9            {|xor cx,cx|}
      /$8A/$0E/xchr_string  {|mov cl,[xchr_string]|}
      /$AC/$D7/$AA   {|@@1: lodsb; xlat; stosb|}
      /$E2/<-5);          {|loop @@1|}
@<Write a line of Pascal code@>;
if line>=p_line then
  begin print('.');
  if line>=n_line then
    begin print(n_line:1); n_line:=n_line+500;
    end;
  p_line:=p_line+100;
@z
%---------------------------------------
@x [10] m.97 l.1823 flush_buffer - optimization
  for k:=break_ptr to out_ptr-1 do out_buf[k-break_ptr]:=out_buf[k];
@y
  move(out_buf[break_ptr],out_buf[0],out_ptr-break_ptr);
@z
%---------------------------------------
@x [10] m.101 l.1886 send_out - optimization
if t<>misc then for k:=1 to v do app(out_contrib[k])
@y
if t<>misc then begin
  move(out_contrib,out_buf[out_ptr],v); Inc(out_ptr,v);
  end
@z
%---------------------------------------
@x [10] m.105 l.1935 - TP extensions, lower case output
 (((out_contrib[1]="D")and(out_contrib[2]="I")and(out_contrib[3]="V")) or@|
 ((out_contrib[1]="M")and(out_contrib[2]="O")and(out_contrib[3]="D")) ))or@|
@y
 (((out_contrib[1]="d")and(out_contrib[2]="i")and(out_contrib[3]="v")) or@|
 ((out_contrib[1]="a")and(out_contrib[2]="n")and(out_contrib[3]="d")) or@|
 ((out_contrib[1]="s")and(out_contrib[2]="h")and
  ((out_contrib[3]="l")or(out_contrib[3]="r"))) or@|
 ((out_contrib[1]="m")and(out_contrib[2]="o")and(out_contrib[3]="d")) ))or@|
@z
%---------------------------------------
@x [10] m.110 l.2004 - TP extensions, lower case output
  if ((out_buf[out_ptr-3]="D")and(out_buf[out_ptr-2]="I")and
    (out_buf[out_ptr-1]="V"))or @/
     ((out_buf[out_ptr-3]="M")and(out_buf[out_ptr-2]="O")and
    (out_buf[out_ptr-1]="D")) then@/ goto bad_case
@y
  if ((out_buf[out_ptr-3]="d")and(out_buf[out_ptr-2]="i")and
    (out_buf[out_ptr-1]="v"))or @/
     ((out_buf[out_ptr-3]="a")and(out_buf[out_ptr-2]="n")and
    (out_buf[out_ptr-1]="d"))or @/
     ((out_buf[out_ptr-3]="s")and(out_buf[out_ptr-2]="h")and
      ((out_buf[out_ptr-1]="l")or(out_buf[out_ptr-1]="r")))or @/
     ((out_buf[out_ptr-3]="x")and(out_buf[out_ptr-2]="o")and
    (out_buf[out_ptr-1]="r"))or @/
     ((out_buf[out_ptr-3]="m")and(out_buf[out_ptr-2]="o")and
    (out_buf[out_ptr-1]="d")) then@/ goto bad_case;@/
if (out_ptr=break_ptr+2)or
 ((out_ptr=break_ptr+3)and(out_buf[break_ptr]=" ")) then
  if (out_buf[out_ptr-2]="o")and(out_buf[out_ptr-1]="r") then goto bad_case
@z
%---------------------------------------
@x [11] m.112 l.2030 - scan phase
else  begin print_nl('Writing the output file'); update_terminal;@/
@y
else  begin print_nl('Scanning the output'); update_terminal;@/
  @<Initialize the output stacks@>; scan_the_output;@/
  print_nl('Writing the output file(s)'); update_terminal;@/
@z
%---------------------------------------
@x [11] m.113 l.2042 - scan phase
@p procedure send_the_output;
@y
@p @<Declare the procedure |scan_the_output| and procedures used by
|send_the_output|@>@;
@#
procedure send_the_output;
@z
%---------------------------------------
@x [11] m.113 l.2046 send_the_output - optimization (for inline code)
  @!k:0..line_length; {index into |out_contrib|}
@y
  @!k:0..line_length; {index into |out_contrib|}
@z
%---------------------------------------
@x [11] m.113 l.2049 - TP extensions
  @!n:integer; {number being scanned}
@y
  @!n:integer; {number being scanned}
  @!p:name_pointer;
@z
%---------------------------------------
@x [11] m.113 l.2060 - TP extensions
  @<Other printable characters@>: send_out(misc,cur_char);
@y
  @<Other printable characters@>:
    @<Handle printable characters and test for end of |program| head@>;
@z
%---------------------------------------
@x [11] m.113 l.2071 - split file or unit
  continue: end;
end;
@y
  continue: end;
end;
@#
split_or_unit(TP_join)(TP_main) {end of split file or unit}
@z
%---------------------------------------
@x [11] m.114 l.2075 - lower case output
and_sign: begin out_contrib[1]:="A"; out_contrib[2]:="N"; out_contrib[3]:="D";
@y
and_sign: begin out_contrib[1]:="a"; out_contrib[2]:="n"; out_contrib[3]:="d";
@z
%---------------------------------------
@x [11] m.114 l.2079 - lower case output
not_sign: begin out_contrib[1]:="N"; out_contrib[2]:="O"; out_contrib[3]:="T";
@y
not_sign: begin out_contrib[1]:="n"; out_contrib[2]:="o"; out_contrib[3]:="t";
@z
%---------------------------------------
@x [11] m.114 l.2082 - lower case output
set_element_sign: begin out_contrib[1]:="I"; out_contrib[2]:="N";
@y
set_element_sign: begin out_contrib[1]:="i"; out_contrib[2]:="n";
@z
%---------------------------------------
@x [11] m.114 l.2085 - lower case output
or_sign: begin out_contrib[1]:="O"; out_contrib[2]:="R"; send_out(ident,2);
@y
or_sign: begin out_contrib[1]:="o"; out_contrib[2]:="r"; send_out(ident,2);
@z
%---------------------------------------
@x [11] m.116 l.2129 - optimization
@d up_to(#)==#-24,#-23,#-22,#-21,#-20,#-19,#-18,#-17,#-16,#-15,#-14,
  #-13,#-12,#-11,#-10,#-9,#-8,#-7,#-6,#-5,#-4,#-3,#-2,#-1,#

@y
@z
%---------------------------------------
@x [11] m.116 l.2133 - lower case output
"A",up_to("Z"): begin out_contrib[1]:=cur_char; send_out(ident,1);
  end;
"a",up_to("z"): begin out_contrib[1]:=cur_char-@'40; send_out(ident,1);
@y
"A".."Z","a".."z": begin out_contrib[1]:=cur_char; send_out(ident,1);
@z
%---------------------------------------
@x [11] m.116 l.2137 - TP extensions, optimization
identifier: begin k:=0; j:=byte_start[cur_val]; w:=cur_val mod ww;
  while (k<max_id_length)and(j<byte_start[cur_val+ww]) do
    begin incr(k); out_contrib[k]:=byte_mem[w,j]; incr(j);
    if out_contrib[k]>="a" then out_contrib[k]:=out_contrib[k]-@'40
    else if out_contrib[k]="_" then decr(k);
    end;
@y
identifier: begin
@<Handle special identifiers, if appropriate |goto continue|@>;
Inline($8B/$1E/cur_val    {|mov bx,[cur_val]|}
      /$8B/$D3            {|mov dx,bx|}
      /$01/$DB            {|add bx,bx|}
      /$81/$C3/byte_start {|add bx,[byte_start]|}
      /$8B/$37            {|mov si,[bx]|}
      /$8B/$4F/4          {|mov cx,[bx+4]|}
      /$2B/$CE            {|sub cx,si|}
      /$BF/out_contrib    {|mov di,out_contrib|}
      /$8C/$D8            {|mov ax,ds|}
      /$8E/$C0            {|mov es,ax|}
      /$FC                {|cld|}
      /$BB/p_byte_mem     {|mov bx,p_byte_mem|}
      /$80/$E2/1          {|and dl,1|}
      /$74/<+3            {|jz @@1|}
      /$83/$C3/4          {|add bx,4|}
      /$C5/$07       {|@@1: lds ax,[bx]|}
      /$03/$F0            {|add si,ax|}
      /$BA/>max_id_length {|mov dx,max_id_length|}
      /$E3/<+11           {|jcxz @@4|}
      /$AC           {|@@2: lodsb|}
      /$3C/"_"            {|cmp al,"_"|}
      /$74/<+4            {|jz @@3|}
      /$AA                {|stosb|}
      /$4A                {|dec dx|}
      /$7E/<+2            {|jle @@4|}
      /$E2/<-11      {|@@3: loop @@2|}
      /$8C/$C0       {|@@4: mov ax,es|}
      /$8E/$D8            {|mov ds,ax|}
      /$81/$EA/>max_id_length {|sub dx,max_id_length|}
      /$F7/$DA            {|neg dx|}
      /$88/$56/<k);       {|mov [bp+k],dl|}
@z
%---------------------------------------
@x [11] m.119 l.2204 - TP type hex constants
  repeat if cur_char>="A" then cur_char:=cur_char+10-"A"
@y
  repeat if cur_char>="a" then cur_char:=cur_char+10-"a"
  else if cur_char>="A" then cur_char:=cur_char+10-"A"
@z
%---------------------------------------
@x [11] m.119 l.2209 - TP type hex constants
  until (cur_char>"F")or(cur_char<"0")or@|
@y
  until (cur_char>"f")or(cur_char<"0")or@|
    ((cur_char>"F")and(cur_char<"a"))or@|
@z
%---------------------------------------
@x [12] m.124 l.2299 - main
@!ii:integer; {general purpose |for| loop variable in the outer block}
@y
@z
%---------------------------------------
@x [12] m.124 l.2300 - optimization
@!line:integer; {the number of the current line in the current file}
@!other_line:integer; {the number of the current line in the input file that
  is not currently being read}
@!temp_line:integer; {used when interchanging |line| with |other_line|}
@y
@!line:Word; {the number of the current line in the current file}
@!other_line:Word; {the number of the current line in the input file that
  is not currently being read}
@!temp_line:Word; {used when interchanging |line| with |other_line|}
@z
%---------------------------------------
@x [12] m.124 l.2305 - optimization (for inline code)
@!loc:0..buf_size; {the next character position to be read from the buffer}
@y
@!loc:Word; {the next character position to be read from the buffer}
@z
%---------------------------------------
@x [12] m.132 l.2401 ckeck_change - optimization
var n:integer; {the number of discrepancies found}
@y
var n:Integer; {the number of discrepancies found}
@z
%---------------------------------------
@x [12] m.134 l.2447 - file handling
changing:=true; prime_the_change_buffer; change_changing;@/
@y
changing:=true;
if change_limit<>0 then prime_the_change_buffer; change_changing;@/
@z
%---------------------------------------
@x [12] m.140 l.2562 - optimization
  while buffer[loc]<>"@@" do incr(loc);
  if loc<=limit then
    begin loc:=loc+2; c:=control_code(buffer[loc-1]);
@y
  Inline($FC              {|cld|}
        /$BF/buffer       {|mov di,buffer|}
        /$03/$3E/loc      {|add di,[loc]|}
        /$8C/$D8/$8E/$C0  {|mov ax,ds; mov es,ax|}
        /$B0/"@@"         {|mov al,"@@"|}
        /$B9/>buf_size+2  {|mov cx,buf_size+2|}
        /$F2/$AE          {|repnz scasb|}
        /$81/$EF/buffer   {|sub di,buffer|}
        /$89/$3E/loc);    {|mov [loc],di|}
  if loc<=limit then
    begin incr(loc); c:=control_code(buffer[loc-1]);
@z
%---------------------------------------
@x [13] m.145 l.2659 - optimization, TP type hex constants
"A",up_to("Z"),"a",up_to("z"): @<Get an identifier@>;
@y
"A".."Z","a".."z": @<Get an identifier@>;
"$": begin c:= hex; scanning_hex:= true end;
@z
%---------------------------------------
@x [13] m.146 l.2677 - TP type hex constants
if ((c>="0")and(c<="9"))or((c>="A")and(c<="F")) then goto found
@y
if ((c>="0")and(c<="9"))or((c>="A")and(c<="F"))or@|
   ((c>="a")and(c<="f")) then goto found
@z
%---------------------------------------
@x [14] m.158 l.2881 - arithmetic
    add_in(equiv[q]-@'100000);
@y
    add_in(integer(equiv[q])-@'100000);
@z
%---------------------------------------
@x [14] m.162 l.2917 - TP type hex constants
repeat if next_control>="A" then next_control:=next_control+"0"+10-"A";
val:=16*val+next_control-"0"; next_control:=get_next;
until (next_control>"F")or(next_control<"0")or@|
@y
repeat if next_control>="a" then next_control:=next_control+"0"+10-"a"
else if next_control>="A" then next_control:=next_control+"0"+10-"A";
val:=16*val+next_control-"0"; next_control:=get_next;
until (next_control>"f")or(next_control<"0")or@|
  ((next_control>"F")and(next_control<"a"))or@|
@z
%---------------------------------------
@x [15] m.165 l.2961 scan_repl - array_type macros
  "#": if t=parametric then a:=param;
@y
  "#": if (t=parametric)or(t=array_type) then a:=param;
@z
%---------------------------------------
@x [15] m.165 l.2975 scan_repl - optimization
if z=zz-1 then z:=0@+else incr(z);
@y
z:=(z+1)and zz1;
@z
%---------------------------------------
@x [15] m.167 l.2989 - optimization
identifier: begin a:=id_lookup(normal); app_repl((a div @'400)+@'200);
  a:=a mod @'400;
@y
identifier: begin a:=id_lookup(normal); app_repl(Hi(a)+@'200); a:=Lo(a);
@z
%---------------------------------------
@x [15] m.167 l.2993 - optimization
  else  begin app_repl((cur_module div @'400)+@'250);
    a:=cur_module mod @'400;
@y
  else  begin app_repl(Hi(cur_module)+@'250); a:=Lo(cur_module);
@z
%---------------------------------------
@x [16] m.174 l.3107 - array_type macros
if next_control="(" then
@y
begin p:=parametric;
if next_control="[" then p:=array_type;
if (p=parametric)and(next_control="(")or@|
   (p=array_type)and(next_control="[") then
@z
%---------------------------------------
@x [16] m.174 l.3111 - array_type macros
    if next_control=")" then
@y
    if (p=parametric)and(next_control=")")or@|
       (p=array_type)and(next_control="]") then
@z
%---------------------------------------
@x [16] m.174 l.3119 - array_type macros
        begin define_macro(parametric); goto continue;
@y
        begin define_macro(p); goto continue;
@z
%---------------------------------------
@x [16] m.174 l.3123 - array_type macros
  end;
@y
  end;
end
@z
%---------------------------------------
@x [17] m.179 l.3182 - terminal io
any error stop will set |debug_cycle| to zero.
@y
any error stop will set |debug_cycle| to zero.

@d term_in==Input {the user's terminal as an input file}
@z
%---------------------------------------
@x [17] m.179 l.3186 - optimization
@!ddt:integer; {operation code for the |debug_help| routine}
@!dd:integer; {operand in procedures performed by |debug_help|}
@!debug_cycle:integer; {threshold for |debug_help| stopping}
@!debug_skipped:integer; {we have skipped this many |debug_help| calls}
@!term_in:text_file; {the user's terminal as an input file}
@y
@!ddt:Integer; {operation code for the |debug_help| routine}
@!dd:Integer; {operand in procedures performed by |debug_help|}
@!debug_cycle:Integer; {threshold for |debug_help| stopping}
@!debug_skipped:Integer; {we have skipped this many |debug_help| calls}
@z
%---------------------------------------
@x [17] m.180 l.3197 - optimization
trouble_shooting:=false; debug_cycle:=99999; {use these when it almost works}
@y
trouble_shooting:=false; debug_cycle:=16000; {use these when it almost works}
@z
%---------------------------------------
@x [17] m.180 l.3198 - terminal io
reset(term_in,'TTY:','/I'); {open |term_in| as the terminal, don't do a |get|}
@y
@z
%---------------------------------------
@x [17] m.181 l.3206 debug_help - optimization
var k:integer; {index into various arrays}
@y
var k:Integer; {index into various arrays}
@z
%---------------------------------------
@x [18] m.182 l.3238 - main, banner+Dos_TP_version, scan_phase
@p begin initialize;
@<Initialize the input system@>;
print_ln(banner); {print a ``banner line''}
@y
@p procedure tgl_main;
var ii:integer; {general purpose |for| loop variable}
begin print_ln(banner+Dos_TP_version); {print a ``banner line''}
initialize;
key_init; {initialize the keywords}
@<Initialize the input system@>;
@z
%---------------------------------------
@x [18] m.182 l.3241 - file handling
@<Phase I: Read all the user's text and compress it into |tok_mem|@>;
@y
@<Open output...@>@;
@<Phase I: Read all the user's text and compress it into |tok_mem|@>;
@z
%---------------------------------------
@x [18] m.182 l.3244 - main
end_of_TANGLE:
@y
end;
@#
procedure close_files_and_terminate;
var ii:integer; {general purpose |for| loop variable}
stat @!wo:0..ww-1; {segment of memory for which statistics are being printed}
tats
begin
@z
%---------------------------------------
@x [18] m.182 l.3247 - file handling
@t\4\4@>{here files should be closed if the operating system requires it}
@y
t_close(Pascal_file); t_close(pool);
@z
%---------------------------------------
@x [18] m.182 l.3249 - main, set return code
end.
@y
end;
@#
begin {beginning of the main program}
tgl_main;
end_of_TANGLE:
close_files_and_terminate; Halt(history);
end.
@z
%---------------------------------------
@x [18] m.185 l.3272 - main
stat @!wo:0..ww-1; {segment of memory for which statistics are being printed}
tats
@y
@z
%---------------------------------------
@x [18] m.187 l.3297 - terminate last line
end {there are no other cases}
@y
end; {there are no other cases}
new_line
@z
%---------------------------------------
@x [19] m.188 l.3300 - additions
This module should be replaced, if necessary, by changes to the program
that are necessary to make \.{TANGLE} work at a particular installation.
It is usually best to design your change file so that all changes to
previous modules preserve the module numbering; then everybody's version
will be consistent with the printed program. More extensive changes,
which introduce new modules, can be inserted here; then only the index
itself will get a new module number.
@^system dependencies@>
@y
This module is replaced, as recommended, by changes to the program
that are necessary to make \.{TANGLE} work at a particular installation.
Here we add the more extensive changes for this \TP\ version
of \.{\title}.
Apart from all the changes necessary to translate \.{\title} with the
\TP\ compiler and some optimization there are three major changes in
the operation of \.{\title} which are all somehow related to to the
addressing mechanism of the INTEL 8086 processor.

First the data segment of a \TP\ program must not be larger than 64k
bytes. Therefore large arrays must often be allocated dynamically via
|new| and all references to array elements have to changed accordingly.
Most of these changes can be performed automatically by \.{TANGE} using
|array_type| macros which treat references to array elements as if they
were references to |parametric| macros.

Second the code segment of a \TP\ program or unit must not exceed 64k
bytes. Large programs (notably \TeX) must be split into a main program
and one or several program unit which can be compiled separately.
This \TP\ version of \.{\title} will automatically provide the
required interface parts for such \TP\ units. These interface parts
will contain all global |const|, |type| and |var| declarations and
the head of all top level |function|s and |procedure|s which are
declared in one unit and invoked in another unit or in the main program.
Likewise |forward| declarations are omitted from the implementation part
as appropriate. Finally a special mechanism is provided for functions
and procedures which are declared |forward| in one unit and defined in
another one. For the moment this last feature does, however, require
that the actual definition contains the full head including the
arguments and, for functions, the result type.

Finally the size of an input file to be processed by the \.{IDE} version
of the \TP\ compiler must not exceed 64k bytes.  Therefore \.{\title-TP}
can split the Pascal code into several files and will automatically
provide the compiler directives to include secondary files.
@^system dependencies@>

@d do_none(#)==do_none_end {neither split file nor unit}
@d do_none_end(#)==
@#
@d do_split(#)==#@; do_split_end {create a split file}
@d do_split_end(#)==
@#
@d do_unit(#)==do_unit_end {create a unit}
@d do_unit_end(#)==#
@#
@d compiler_directives_for_unit==
  TP_int@;
  TP_dir(R-,S+,I+,F-) {no range check}
  @!debug TP_dir(R+)@+ gubed {but turn range check on when debugging}
  TP_imp@;
  TP_auto@;

@* Initialization of the keywords.
First we have to initialize several identifiers which play a special
r\^ole.  The function |id_init| is used to initialize identifiers with
|normal| ilk.

@<Declare the procedure |scan...@>=
function id_init(@!s:str_15):name_pointer;
begin id_first:=1; id_loc:=1;
while id_loc<=Length(s) do
  begin buffer[id_loc]:=xord[s[id_loc]]; incr(id_loc);
  end;
id_init:=id_lookup(normal);
end;
@#
procedure key_init; {initialize the keywords}
var t:0..max_toks;
begin @<Initialize the keywords@>@;
end;

@ @<Types...@>=
@!str_15=String[15];

@ Here we initialize all the special identifiers for \.{\title-TP}.

@<Initialize the keywords@>=
id_ifdef:=id_init('TP_ifdef');
id_else:=id_init('TP_else');
id_endif:=id_init('TP_endif');@/
id_split:=id_init('TP_split');
id_join:=id_init('TP_join');@/
id_unit_unit:=id_init('TP_unit');
id_unit_body:=id_init('TP_body');
id_unit_main:=id_init('TP_main');@/
id_auto:=id_init('TP_auto');
id_imp:=id_init('TP_imp');
id_int:=id_init('TP_int');@/

@ @<Glob...@>=
@!id_ifdef,@!id_else,@!id_endif,@!id_split,@!id_join,
@!id_unit_unit,@!id_unit_body,@!id_unit_main,
@!id_auto,@!id_imp,@!id_int:name_pointer;

@ In addition we must recognize several of \TP's reserved identifiers.
The identifiers appear in a certain sequence that occasionally
corresponds to a sequence of |scan_state| values defined later on.

@<Initialize the keywords@>=
id_interface:=id_init('interface');
id_implementation:=id_init('implementation');@/
id_uses:=id_init('uses');
id_unit:=id_init('unit');
id_program:=id_init('program');@/
id_function:=id_init('function');
id_procedure:=id_init('procedure');
id_constructor:=id_init('constructor');
id_destructor:=id_init('destructor');@/
id_forward:=id_init('forward');
id_external:=id_init('External');
id_near:=id_init('Near');
id_far:=id_init('Far');
id_inline:=id_init('Inline');@/
id_begin:=id_init('begin');
id_asm:=id_init('asm');
id_object:=id_init('object');
id_record:=id_init('record');
id_case:=id_init('case');@/
id_end:=id_init('end');
id_var:=id_init('var');

@ @<Glob...@>=
@!id_interface,@!id_implementation,@/
@!id_uses,@!id_unit,@!id_program,@/
@!id_function,@!id_procedure,@!id_constructor,@!id_destructor,@/
@!id_near,@!id_far,@!id_forward,@!id_inline,@!id_external,@/
@!id_begin,@!id_asm,@!id_object,@!id_record,@!id_case,@/
@!id_end,@!id_var:name_pointer;

@* Analyzing the Pascal syntax.
The output phase of \.{\title} does not use the |link| entries for
identifiers (|llink| entries for modules); the same is true for the
|equiv| and |text_link| entries for normal identifiers (with
|ilk=normal|). At the start of the procedure |scan_the_output| we will
initialize all |link| entries. Later on these entries will be used to
detect functions\slash procedures defined in one \TP-unit and used in
another one.

Modules and different kinds of identifiers will primarily be
distinguished by their |link| values. The |equiv| field of some normal
identifiers will be used to record additional information.

@d not_id=0 {used for modules and macros}
@d id_normal=1 {normal identifiers}
@d id_uses_name=2 {identifiers for uses names}
@d id_ifdef_name=3 {for the identifier |id_ifdef|}
@d id_else_name=4 {identifiers for active |ifdef| names}
@d id_endif_name=5 {identifiers for active |ifdef| names after |else|}
@d id_local=6 {this function or procedure is definitely local}
@#
@d id_expl=7 {a normal function or procedure (defined in this unit)}
@d id_ext=id_expl+1 {declared external}
@d id_cross_u=id_expl+2 {declared forward across units, not yet defined}
@d id_cross_d=id_expl+3 {declared forward across units, defined}
@d id_inl=id_expl+4 {declared Inline}
@d id_forwd_u=id_expl+5 {declared forward, not yet defined}
@d id_forwd_d=id_expl+6 {declared forward, defined}
@#
@d id_global=7 {add this amount to the above if used globally}
@d id_may_be=14 {add this amount to the above if defined in a previous
  unit and not yet used outside that unit}

@<If this identifier is new...@>=
if link[a]=not_id then
  begin link[a]:=id_normal; equiv[a]:=0;
  end

@ In the function |get_output| we keep track of the syntax of the Pascal
code. The global variable |scan_state| records the current state of
function\slash procedure definitions. Another global variables
|proc_level| records the current level of function\slash procedure
declarations and |scan_level| keeps track of the level of
|begin|\dots|end| or |(|\dots|)| grouping.

@d initial=0 {value of |scan_state| before |program| or |unit|}
@d func_id=1 {|function| has been scanned}
@d proc_id=func_id+1 {|procedure| has been scanned}
@d constr_id=proc_id+1 {|constructor| has been scanned}
@d destr_id=constr_id+1 {|destructor| has been scanned}
@d func_name=destr_id+1 {|function| name has been scanned}
@d proc_name=func_name+1 {|procedure| name has been scanned}
@d constr_name=proc_name+1 {|constructor| name has been scanned}
@d destr_name=constr_name+1 {|destructor| name has been scanned}
@d head=destr_name+1 {during |function| or |procedure| head}
@d head_end=head+1 {at |";"| of |function| or |procedure| head}
@d prog_head=head_end+1 {during |program| or |unit| head}
@d prog_head_end=prog_head+1 {at |";"| of |program| or |unit| head}
@d head_forwd=prog_head_end+1
  {at |forward| after |function| or |procedure| head}
@d head_ext=head_forwd+1
  {at |External| after |function| or |procedure| head}
@d head_near=head_ext+1
  {at |Near| after |function| or |procedure| head}
@d head_far=head_near+1
  {at |Far| after |function| or |procedure| head}
@d head_inl=head_far+1
  {at |Inline(|\dots|)| after |function| or |procedure| head}
@d decl=head_inl+1 {during declarations}
@d int_decl=decl+1 {during |interface| declarations}
@d obj_decl=int_decl+1 {during |object| declarations}
@d main_body=obj_decl+1 {at |begin| of main program}
@d body=main_body+1 {during |function| or |procedure| body}
@d body_end=body+1 {at |end| of a top level |function| or |procedure|}
@d body_done=body_end+1
  {at |";"| at end of a top level |function| or |procedure|}
@d final=body_done+1 {at |end| of main program}
@d final_end=final+1 {after |end| of main program}
@d unclear=final_end+1 {confusion}

@<Glob...@>=
@!scan_phase: boolean; {|true| only during |scan_the_output|}
@!is_unit: boolean; {is the `main program' a unit?}
@!scan_state:initial..unclear; {current state}
@!proc_level:Integer;
  {current level of function/procedure declarations}
@!scan_level:Integer; {current level of grouping}

@ @<Set init...@>=
scan_phase:=false;

@ @<Initialize the output stacks@>=
is_unit:=false; scan_state:=initial;

@ The following code updates the value of |scan_state| and is part of
the function |get_output|.  The code does not check very carefully for a
correct Pascal program but should be sufficiently robust.  We say |goto
restart| in order to discard the current token and we say |goto found|
to reanalyze the token.

@d change_scan_state(#)== {change |scan_state| and reanalyze token}
  begin scan_state:=#; goto found;
  end

@<Analyze the syntax...@>=
if a=0 then scan_state:=unclear
else if is_unit and(a=identifier)and@|
 (cur_val<=id_unit_main)and(cur_val>=id_unit_unit) then
  begin err_print('! Invalid TP_unit/body/main in explicit unit');
  goto restart;
  end
else case scan_state of
initial: if (a=identifier)and@|
   (cur_val<=id_program)and@|(cur_val>=id_unit) then
    begin proc_level:=1; scan_level:=0; scan_state:=prog_head;
    is_unit:=(cur_val=id_unit);
    end;
func_id..destr_id: if a<>identifier then change_scan_state(decl)
  else Inc(scan_state,func_name-func_id);
func_name..destr_name,head_near..head_far: change_scan_state(head);
head,prog_head,head_inl: if a="(" then incr(scan_level)
  else if (a=")")and(scan_level>0) then decr(scan_level)
  else if (a=";")and(scan_level=0) then incr(scan_state);
head_end: if (a=identifier)and@|
   (cur_val<=id_inline)and@|(cur_val>=id_forward) then
    scan_state:=cur_val-id_forward+head_forwd
  else  begin incr(proc_level); change_scan_state(decl);
    end;
prog_head_end..head_ext: change_scan_state(decl);
decl..obj_decl: if (a=identifier)and(cur_val<=id_end) then
  if cur_val=id_interface then scan_state:=int_decl
  else if cur_val=id_implementation then scan_state:=decl
  else if cur_val=id_object then
    begin incr(scan_level);
    if scan_state=decl then scan_state:=obj_decl;
    end
  else if (cur_val<=id_destructor)and@|(cur_val>=id_function)and@|
   (scan_state=decl)and@|(scan_level=0) then
    scan_state:=cur_val-id_program
  else if cur_val=id_record then incr(scan_level)
  else if cur_val=id_end then
    begin if scan_level>0 then decr(scan_level)
    else if is_unit and(proc_level=1) then change_scan_state(body);
    if (scan_level=0)and(scan_state=obj_decl) then scan_state:=decl;
    end
  else if (cur_val=id_begin)or(cur_val=id_asm) then
    begin scan_level:=1;
    if proc_level=1 then scan_state:=main_body else scan_state:=body;
    end
  else if cur_val=id_unit_body then scan_state:=body;
main_body: change_scan_state(body);
body: if (a=identifier)and(cur_val<=id_end) then
  if (cur_val=id_unit_unit)or(cur_val=id_unit_main) then scan_state:=decl
  else if (cur_val=id_begin)or(cur_val=id_asm)or(cur_val=id_case) then
    incr(scan_level)
  else if cur_val=id_end then
    begin if scan_level>0 then decr(scan_level);
    if scan_level=0 then
      begin decr(proc_level);
      if proc_level=0 then scan_state:=final
      else if proc_level=1 then scan_state:=body_end
      else scan_state:=decl;
      end;
    end;
body_end: if a=";" then scan_state:=body_done;
body_done: change_scan_state(decl);
final: if a="." then scan_state:=final_end;
final_end,unclear: do_nothing;
end

@* Scanning the Pascal output.
The procedure |scan_the_output| is invoked just once, after all the
input has been digested and before the output is produced.
The following procedure is used in |scan_the_output| and in
|send_the_output| to make sure that the next token is an identifier.

@d get_next_id==if not next_id then goto continue

@<Declare the procedure |scan...@>=
function next_id:boolean; {make sure next token is an identifier}
begin
if get_output=identifier then next_id:=true
else  begin err_print('! Missing identifier'); next_id:=false;@+end;
end;

@ Among other things we will build a chain of explicit uses names and
unit names starting at |id_uses| and proceeding through the |equiv|
entries; the variable |uses_tail| will point to the end of this chain.

@d chain_uses==
begin if link[cur_val]<>id_normal then
  begin err_print('! Invalid unit/uses identifier'); goto continue;
  end;
equiv[uses_tail]:=cur_val; link[cur_val]:=id_uses_name;
equiv[cur_val]:=0; uses_tail:=cur_val;
end

@<Globals...@>=
@!uses_tail: name_pointer; {end of chain of uses names}

@ @<Declare the procedure |scan...@>=
procedure scan_the_output;
label reswitch,continue,not_found;
var cur_char:eight_bits; {value returned by |get_output|}
@!p:name_pointer; {pointer to an identifier}
begin scan_phase:=true;
for p:=1 to name_ptr-1 do link[p]:=not_id;
link[id_uses]:=id_uses_name; equiv[id_uses]:=0; uses_tail:=id_uses;
link[id_ifdef]:=id_ifdef_name; equiv[id_ifdef]:=0; ifdef_tail:=id_ifdef;
while stack_ptr>0 do
  begin cur_char:=get_output;
reswitch: if cur_char=identifier then
    begin if (cur_val=id_uses)and not is_unit then @<Scan |uses|@>;
    if (cur_val=id_unit_unit)or(cur_val=id_unit_main) then
      @<Update the |link| values at end of a unit@>;
    if cur_val=id_unit_unit then
      begin get_next_id; chain_uses; goto continue;
      end;
    if (scan_state>=func_name)and(scan_state<=destr_name) then
      if (proc_level<>1)or(scan_state>proc_name) then link[cur_val]:=id_local
      else @<Scan a top level function or procedure declaration@>
    else if link[cur_val]>=id_expl+id_may_be then
      Dec(link[cur_val],id_may_be-id_global);
    end;
continue: end;
@<Update the |link| values at end of program@>;
if scan_state<>final_end then
  begin print_nl('! Unable to analyze Pascal program'); mark_harmless;
  end;
scan_phase:=false;
end;

@ @<Scan |uses|@>=
begin repeat get_next_id; chain_uses; cur_char:=get_output;
 until cur_char<>",";
goto continue;
end

@ At the end of a unit we update the |link| values for all top level
functions and procedures as follows.  First we change |id_forwd_u| into
|id_cross_u+id_global|.  Then we add |id_may_be| for all other
identifiers declared in the unit just ended.

@<Update the |link| values at end of a unit@>=
for p:=1 to name_ptr-1 do
  if link[p]=id_forwd_u then link[p]:=id_cross_u+id_global
  else if (link[p]>=id_expl)and(link[p]<id_expl+id_global) then
    Inc(link[p],id_may_be)

@ At the end of the program we update the |link| values for all top
level functions and procedures as follows.  First we subtract
|id_may_be| for all identifiers declared in a previous unit and never
used outside that unit.  Then we change |id_forwd_u| and
|id_cross_u+id_global| into |id_local| and give an error message that
these identifiers were never defined.

@<Update the |link| values at end of program@>=
for p:=1 to name_ptr-1 do
  begin if link[p]>=id_expl+id_may_be then Dec(link[p],id_may_be);
  if (link[p]=id_forwd_u)or(link[p]=id_cross_u+id_global) then
    begin link[p]:=id_local; print_nl('! forward function/procedure ');
    print_id(p); print(' not defined.'); mark_harmless;
    end;
  end

@ The following code will scan the declaration of a top level function
or procedure and update the |link| value accordingly.
In case there are any problems we set |link| to |id_local|.

@<Scan a top level function or procedure declaration@>=
begin p:=cur_val;
not_found: repeat cur_char:=get_output;
  until scan_state<>head;
if scan_state<>head_end then
  begin link[p]:=id_local; {something is wrong ?}
  goto reswitch; {reanalyze the last token}
  end
else  begin cur_char:=get_output;
  if proc_level<>1 then
    begin if link[p]=id_normal then link[p]:=id_expl {a normal definition}
    else if (link[p]=id_forwd_u)or(link[p]=id_cross_u+id_global) then
      incr(link[p]) {now the function or procedure is defined}
    else link[p]:=id_local; {something is wrong ?}
    goto reswitch; {reanalyze the last token}
    end
  else if (scan_state=head_near)or(link[p]<>id_normal) then
    link[p]:=id_local {a Near declaration or something is wrong ?}
  else if scan_state=head_forwd then
    link[p]:=id_forwd_u {a forward declaration}
  else if scan_state=head_ext then
    link[p]:=id_ext {an External declaration}
  else if scan_state=head_inl then
    link[p]:=id_inl {an Inline declaration}
  else goto not_found; {a Far declaration}
  end;
end

@* Splitting the Pascal output.
This version of \.{\title} will route part of the Pascal output to
several alternate files.

@<Globals...@>=
@!split_file: text_file; {alternate output file}
@!splitting: boolean; {are we writing to |split_file| ?}
@!unit_file: text_file; {output file for units}
@!to_unit: boolean; {are we writing to |unit_file| ?}
@!int_file: text_file; {output file for interface section of units}
@!to_imp: boolean; {are we writing to implementation file ?}
@!to_int: boolean; {are we writing to interface file ?}
@!temp_file: text_file; {scratch file}
@!to_temp: boolean; {are we writing to temp file ?}
@!tmp_open: boolean; {are any lines written to temp file ?}

@ @<Set init...@>=
splitting:=false; to_unit:=false; to_imp:=true; to_int:=false;
to_temp:=false; tmp_open:=false;

@ @<Write a line of Pascal code@>=
if to_temp then
  begin write_ln(temp_file,xchr_string); incr(line);
  end
else  begin if to_imp then
    begin if splitting then write_ln(split_file,xchr_string)
    else if to_unit then write_ln(unit_file,xchr_string)
    else write_ln(Pascal_file,xchr_string);
    incr(line);
    end;
  if to_int then
    begin write_ln(int_file,xchr_string);
    incr(line);
    end;
  end

@ Here now are the changes in the procedure |send_the_output|.
First we need a few procedures which need not be very efficient
since they are used rather infrequently.

@<Declare the procedure |scan...@>=
procedure send_ident(p:name_pointer); {send out an identifier}
var k:0..line_length; {index into |out_contrib|}
@!j:0..max_bytes; {index into |byte_mem|}
@!w:0..ww-1; {segment of |byte_mem|}
begin j:=byte_start[p]; w:=p and ww1;
k:=byte_start[p+ww]-j; move(byte_mem[w,j],out_contrib[1],k);
send_out(ident,k);
end;
@#
procedure xchr_ident; {convert current identifier to string}
var k:0..255; {index into |xchr_string|}
@!j:0..max_bytes; {index into |byte_mem|}
@!w:0..ww-1; {segment of |byte_mem|}
begin j:=byte_start[cur_val]; w:=cur_val and ww1;
xchr_length:=byte_start[cur_val+ww]-j;
for k:=1 to xchr_length do xchr_string[k]:=xchr[byte_mem[w,j+k-1]];
end;

@ During |send_the_output| we will maintain a list of active |ifdef|
and |else| compiler directives starting at |id_ifdef| and proceeding
through the |equiv| entries; the variable |ifdef_tail| will point to
the end of this chain. The |link| field of the chained identifiers will
be either |id_else_name| or |id_endif_name| depending on whether we are
still expecting or have already passed an |else|.

@<Globals...@>=
@!ifdef_tail: name_pointer; {end of chain of ifdef names}

@ The following three procedures are used to send |ifdef|, |else| and
|endif| compiler directives.

@<Declare the procedure |scan...@>=
procedure send_ifdef(p:name_pointer); {send out an |ifdef|}
begin out_contrib[1]:="{"; out_contrib[2]:="$"; out_contrib[3]:="i";
out_contrib[4]:="f"; out_contrib[5]:="d"; out_contrib[6]:="e";
out_contrib[7]:="f"; out_contrib[8]:=" "; send_out(str,8);
out_state:=unbreakable; send_ident(p); send_out(misc,"}");
end;
@#
procedure send_else; {send out an |else|}
begin out_contrib[1]:="{"; out_contrib[2]:="$"; out_contrib[3]:="e";
out_contrib[4]:="l"; out_contrib[5]:="s"; out_contrib[6]:="e";
send_out(str,6); send_out(misc,"}");
end;
@#
procedure send_endif; {send out an |endif|}
begin out_contrib[1]:="{"; out_contrib[2]:="$"; out_contrib[3]:="e";
out_contrib[4]:="n"; out_contrib[5]:="d"; out_contrib[6]:="i";
out_contrib[7]:="f"; send_out(str,7); send_out(misc,"}");
end;

@ The procedure |push_ifdef| will add en identifier to the ifdef chain
and send an |ifdef| compiler directive.
The procedure |pop_ifdef| will remove the last identifier from the chain
and send an |endif| compiler directive.

@<Declare the procedure |scan...@>=
procedure push_ifdef;
begin if link[cur_val]<>id_normal then err_print('! Illegal TP_ifdef name')
else  begin equiv[ifdef_tail]:=cur_val; ifdef_tail:=cur_val;
  equiv[cur_val]:=0;
  end;
send_ifdef(cur_val);
end;
@#
procedure pop_ifdef;
var p,@!q:name_pointer;
begin q:=id_ifdef; {at this point the ifdef chain is not empty}
  repeat p:=q; q:=equiv[p];
  until q=ifdef_tail;
ifdef_tail:=p; equiv[p]:=0; link[q]:=id_normal; send_endif;
end;

@ At certain points we will call the procedure |check_ifdef| to make
sure that there is no unfinished |ifdef| compiler directive.
Two other procedures |susp_ifdef| and |init_ifdef| will be called
immediately before and after changing the output destination
(e.g., at the start and end of a split file or when switching
between the interface and implementation part of a unit) in order
to suspend and reestablish any pending |ifdef| and |else| compiler
directives.

@<Declare the procedure |scan...@>=
procedure check_ifdef; {terminate any unfinished |ifdef|}
begin while ifdef_tail<>id_ifdef do
  begin err_print('! Missing TP_endif'); pop_ifdef;@+end;
end;
@#
procedure susp_ifdef; {suspend any unfinished |ifdef|}
var p:name_pointer;
begin p:=id_ifdef;
while p<>ifdef_tail do
  begin p:=equiv[p]; send_endif;@+end;
end;
@#
procedure init_ifdef; {reestablish any unfinished |ifdef| and |else|}
var p:name_pointer;
begin p:=id_ifdef;
while p<>ifdef_tail do
  begin p:=equiv[p]; send_ifdef(p);
  if link[p]=id_endif_name then send_else;
  end;
end;

@ The procedure |send_force| is used to force a line break in the
Pascal output (e.g., when changing the output destination).
The procedure |send_include| is used to send an include comiler
directive (on a separate output line).

@<Declare the procedure |scan...@>=
procedure send_force; {force a line break}
@<Force a line break@>;
@#
procedure send_include(a,b,c:ASCII_code);
  {send an include compiler directive}
begin send_force;
out_contrib[1]:="{"; out_contrib[2]:="$"; out_contrib[3]:="I";
out_contrib[4]:=" "; send_out(str,4); send_ident(cur_val);
send_out(misc,"."); send_out(misc,a); send_out(misc,b);
send_out(misc,c); send_out(misc,"}"); send_force;
end;

@ The procedure |out_dest| is used to set the output destination
(the two arguments indicate the new values for |to_imp| and |to_int|).

@<Declare the procedure |scan...@>=
procedure out_dest(t_imp,t_int:boolean); {set |to_imp| and |t_int|}
begin if (t_imp<>to_imp)or(t_int<>to_int)or to_temp then
  begin susp_ifdef; send_force;
  to_imp:=t_imp; to_int:=t_int; to_temp:=false;
  init_ifdef;
  end;
end;

@ The procedure |send_uses| is used to send a |uses| statement.

@<Declare the procedure |scan...@>=
procedure send_uses(t:boolean);
  {send a uses statement and, if |t=true| clear uses chain}
var p,q:name_pointer;
begin q:=id_uses;
if q<>uses_tail then
  begin send_ident(q);
    repeat p:=q; q:=equiv[p]; send_ident(q);
    if q=uses_tail then send_out(misc,";") else send_out(misc,",");
    if t then
      begin equiv[p]:=0; link[q]:=id_normal;
      end;
    until q=uses_tail;
  end;
end;

@ The procedure |send_address| is used to send a statement which
initialized the pointer to a forwarded routine to |temp_file|.
All these statements will later be copied into the body of a unit or
of the main program.

@<Declare the procedure |scan...@>=
procedure send_address;
  {send an initialization statement to |temp_file|}
var k:0..line_length; {index into |out_contrib|}
  @!j:0..max_bytes; {index into |byte_mem|}
  @!w:0..ww-1; {segment of |byte_mem|}
begin if not tmp_open then
  begin Assign(temp_file,temp_name(false));
  rewrite(temp_file); tmp_open:=true;
  end;
susp_ifdef; send_force; to_temp:=true; init_ifdef;
out_contrib[1]:="a"; out_contrib[2]:="_";
send_out(ident,2); out_state:=unbreakable; send_ident(cur_val);
send_out(misc,":"); send_out(misc,"="); send_out(misc,"@@");
k:=1; j:=byte_start[cur_val]; w:=cur_val and ww1;
while (k<=max_id_length)and(j<byte_start[cur_val+ww]) do
  begin out_contrib[k]:=byte_mem[w,j]; incr(j);
  if out_contrib[k]<>"_" then incr(k);
  end;
send_out(ident,k-1); send_out(misc,";"); link[cur_val]:=id_local;
if not to_unit then
  begin susp_ifdef; send_force; to_temp:=false; init_ifdef;
  end;
end;

@ The following code tests if the end of the |program| head has
been found.

@<Handle printable characters...@>=
begin send_out(misc,cur_char);
if scan_state=prog_head_end then
  begin send_uses(true); uses_tail:=id_uses;
  end;
end

@ The following code tests if one of the special identifiers has
been found.

@<Handle special identifiers...@>=
begin if (cur_val<id_begin)or(scan_state=main_body) then
  begin if (cur_val<=id_endif)and(cur_val>=id_ifdef) then
    @<Handle |TP_ifdef|, |TP_else| and |TP_endif|@>;
  if (cur_val<=id_join)and(cur_val>=id_split)or
    splitting and((cur_val<=id_unit_main)or(scan_state=main_body)) then
    @<Handle |TP_split| and |TP_join|@>;
  if (cur_val<=id_int)and(cur_val>=id_auto) then
    @<Handle |TP_auto|, |TP_imp| and |TP_int|@>;
  if to_unit and not in_body and
    (cur_val<=id_unit_main)and(cur_val>=id_unit_unit)or@|
    (scan_state=main_body) then @<Handle |TP_body|@>;
  if (cur_val<=id_unit_main)and(cur_val>=id_unit_unit) then
    @<Handle |TP_unit| and |TP_main|@>;
  if (cur_val=id_uses)and not is_unit then @<Scan |uses|@>;
  end;
if not in_body then
  if to_unit then @<Determine the output destination@>
  else @<Check for functions or procedures declared forward in a unit@>;
end

@ @<Handle |TP_ifdef|, |TP_else| and |TP_endif|@>=
begin
if cur_val=id_ifdef then
  begin get_next_id; push_ifdef;
  end
else if ifdef_tail=id_ifdef then err_print('! Spurious TP_else/endif')
else if cur_val=id_endif then pop_ifdef
else  begin if link[ifdef_tail]=id_endif_name then
    err_print('! Duplicate TP_else');
  send_else; link[ifdef_tail]:=id_endif_name;
  end;
goto continue;
end

@ If |get_output| produces |TP_split file_name| then the
\PASCAL-output is deviated to the |split_file| until |TP_join|
is sensed.

@<Handle |TP_split| and |TP_join|@>=
begin if in_body then
  begin err_print('! Illegal TP_split/join'); goto continue;
  end;
out_dest(true,false); susp_ifdef;
if splitting then
  begin send_force; t_close(split_file); splitting:=false;
  end
else if cur_val=id_join then err_print('! Spurious TP_join');
if cur_val=id_split then
  begin get_next_id; send_include("p","a","s"); xchr_ident;
  t_assign(split_file,out_dir+xchr_string+'.pas');
  splitting:=t_rewrite(split_file);
  end;
print_nl('  Split ');
if splitting then print('to '+xchr_string) else print('ended');
init_ifdef;
if splitting or(cur_val=id_join) then goto continue;
end

@ The global variable |in_body| is true while processing the body of
the main program or of a program unit.

@<Glob...@>=
@!in_body: boolean;

@ @<Set init...@>=
in_body:=false;

@ Normally \.{\title-TP} will decide automatically which parts of a
program unit belong to the interface and which to the implementation.
When, however, |get_output| produces the identifier |TP_imp| or
|TP_int| the following part of the Pascal program will be routed to the
implementation or interface part respectively. The occurence of
|TP_auto| or of a top level function or procedure declaration will
reactivate \.{\title-TP}'s automatic decisions.

@<Glob...@>=
@!to_auto: boolean;
  {should we automatically decide the output destination ?}

@ @<Set init...@>=
to_auto:=false;

@ @<Handle |TP_auto|, |TP_imp| and |TP_int|@>=
begin
if not to_unit or in_body then err_print('! Illegal TP_auto/imp/int')
else  begin if cur_val=id_imp then out_dest(true,false)
  else if cur_val=id_int then out_dest(false,true);
  to_auto:=(cur_val=id_auto);
  end;
goto continue;
end

@ @d start_body==
  begin send_ident(id_begin); in_body:=true;
  end

@<Handle |TP_body|@>=
begin if to_unit then
  begin out_dest(true,false); to_auto:=false; t_close(int_file);
  end;
if (cur_val=id_unit_body)or(scan_state=main_body) then start_body;
@<Initialize the cross unit forward pointers@>;
in_body:=true;
if (cur_val=id_unit_body)or(scan_state=main_body) then goto continue;
end

@ @<Handle |TP_unit| and |TP_main|@>=
begin if to_unit then
  begin send_ident(id_end); send_out(misc,"."); send_force;
  t_close(unit_file); in_body:=false; to_unit:=false;
  if cur_val=id_unit_main then
    begin print_nl(' Main'); goto continue;
    end;
  end;
send_force; get_next_id; xchr_ident;
t_assign(unit_file,out_dir+xchr_string+'.pas');
if not t_rewrite(unit_file) then
  fatal_error('! Unable to open output file ',out_dir,xchr_string+'.pas');
t_assign(int_file,out_dir+xchr_string+'.tpi');
if not t_rewrite(int_file) then
  fatal_error('! Unable to open output file ',out_dir,xchr_string+'.tpi');
print_nl(' Unit ',xchr_string);
to_unit:=true; send_ident(id_unit);
send_ident(cur_val); send_out(misc,";"); send_include("t","p","i");
out_dest(true,false); send_ident(id_implementation);
out_dest(false,true); send_ident(id_interface); send_uses(false);
to_auto:=true; chain_uses; goto continue;
end

@ Here now is the part where we do the actual work to send part of the
Pacal code to the interface file or to the implementation file.
We will use the global variable |cross_id| to handle forward references
across units.

@<Global...@>=
@!cross_id:name_pointer;

@ @<Set init...@>=
cross_id:=0;

@ @d get_func_name== {get function or procedure name}
n:=scan_state-func_id; cur_char:=get_output;
if scan_state<>func_name+n then
  begin send_ident(id_function+n); goto reswitch; {spurious}
  end

@<Determine the output destination@>=
begin if (scan_state<=destr_id)and(scan_state>=func_id) then
  begin to_auto:=true; get_func_name;
  if link[cur_val]<id_expl+id_global then out_dest(true,false)
  else  begin decr(link[cur_val],id_global);
    if link[cur_val]=id_cross_u then send_address;
    out_dest(link[cur_val]<id_cross_d,true);
    if link[cur_val]=id_cross_d then
      begin cross_id:=cur_val; send_ident(id_var);
      out_contrib[1]:="a"; out_contrib[2]:="_";
      send_out(ident,2); out_state:=unbreakable; send_ident(cross_id);
      send_out(misc,":"); out_contrib[1]:="p"; out_contrib[2]:="o";
      out_contrib[3]:="i"; out_contrib[4]:="n"; out_contrib[5]:="t";
      out_contrib[6]:="e"; out_contrib[7]:="r"; send_out(ident,7);
      send_out(misc,";"); link[cur_val]:=id_cross_u+id_global;
      end;
    end;
  send_ident(id_function+n);
  end
else if (scan_state=head_ext)and (to_int or not to_imp) then
  out_dest(true,false)
else if ((scan_state=head_forwd)or(scan_state=head_far))and to_int then
  begin if cross_id<>0 then
    begin send_ident(id_inline);
    out_contrib[1]:="("; out_contrib[2]:="$"; out_contrib[3]:="1";
    out_contrib[4]:="E"; out_contrib[5]:="F"; out_contrib[6]:="F";
    out_contrib[7]:="/"; out_contrib[8]:="a"; out_contrib[9]:="_";
    send_out(str,9); out_state:=unbreakable; send_ident(cross_id);
    send_out(misc,")"); send_out(misc,";"); cross_id:=0;
    end;
  out_dest(false,false);
  end
else if to_auto then
  if proc_level>1 then out_dest(true,false)
  else if scan_state=decl then out_dest(false,true);
end

@ If a function or procedure was declared forward in a unit and is
defined in the main program we must not only initialize a pointer in the
body of the main program but also make sure that a FAR CALL is used.
We temporarily set |to_auto:=true| to indicate that we must reset the
FAR CALL compiler option.

@<Check for functions or procedures declared forward in a unit@>=
begin if (scan_state<=destr_id)and(scan_state>=func_id) then
  begin get_func_name;
  if link[cur_val]=id_cross_u+id_global then
    begin send_address; to_auto:=true;
    out_contrib[1]:="{"; out_contrib[2]:="$"; out_contrib[3]:="F";
    out_contrib[4]:="+"; send_out(str,4); send_out(misc,"}");
    end;
  send_ident(id_function+n);
  end
else if to_auto and(scan_state<>head) then
  begin to_auto:=false;
  out_contrib[1]:="{"; out_contrib[2]:="$"; out_contrib[3]:="F";
  out_contrib[4]:="-"; send_out(str,4); send_out(misc,"}");
  end;
end

@ In the body of a unit or of the main program we must initialize
pointers for all those functions and procedures defined in the unit or
main progam which were declared forward in a previous unit.
There is, however, a subtle point. The definition of the forwarded
function or procedure might be subject to some ifdef's which are no
longer known when this part of the program is executed. Therefore these
instructions are writen by the procedure |send_address| to a scratch
file |temp_file| and copied into the body of the unit or the main
program.

@<Initialize the cross unit forward pointers@>=
if tmp_open then
  begin if not in_body then start_body;
  send_force; a_close(temp_file); reset(temp_file);
  while not eof(temp_file) do
    begin read_ln(temp_file,xchr_string);
    if to_unit then write_ln(unit_file,xchr_string)
    else write_ln(Pascal_file,xchr_string);
    end;
  a_close(temp_file); Erase(temp_file); tmp_open:=false;
  end
@z
%---------------------------------------
